# Рекурсия
Като понятие рекурсията означава повтаряне чрез позоваване на себе си. Например: *приятелите на моите приятели са и мои приятели, директориите съдържат файлове и директории*. Рекурсията съществува и в математиката. Факториел от n, всъщност е равен на n умножен с факториел от n-1 (*n! = n \* (n-1)!*).  

В програмирането рекурсия наричаме **функция, която извиква себе си.** Такива функции съдържат **базов случай** и **рекурсивна стъпка**.  

*Базовият случай* определя за коя стойност е най-простото решение на проблема, тоест кога ще приключи самоизвикването на функцията(т.н. дъно на рекурсията). Ако рекурсивната функция няма добре дефинирано дъно тя ще продължи да се вика неограничен брой пъти. Това се нарича *бездънна рекурсия*. За това е важно винаги да имаме добре дефиниран базов случай.

*Рекурсивната стъпка* показва как задачата може да бъде разделена на по-дребни стъпки. Тоест по какъв начин функцията ще вика сама себе си или каква промяна ще има при следващото себеизвикване. 

### Пример
За да сметнем факториел по горната формула бихме написали функция, която връща n \* резултата, върнат от същата функция, извикана за n-1. Тоест рекурсивната ни стъпка би изглеждала така: 
```c++
int factorial(int n){
    ...
    return n * factorial(n-1);
    ...
}
```
Базовият ни случай трябва да представлява най-простата стойност, за която има решение. В този случай това е 1, защото знаем че 1! = 1. 
```c++
int factorial(int n){
    if(n == 1){
        return 1;
    }
    ...
}
```
Сега остава само да съберем базовия случай с рекурсивната стъпка:
```c++
int factorial(int n){
    if(n==1) {
        return 1;
    }
    else {
        return n * factorial(n-1);
    }
}
```

## Итеративен vs Рекурсивен подход
Нека имаме следната ситуация. Пред нас има една голяма кутия и ние знаем, че някъде в нея е скрит ключ. Отваряме кутията и виждаме, че в нея има още кутии без да знаем в коя точно е ключа. 
<p align="center">
  <img src ="https://cdn-images-1.medium.com/max/2000/1*FVSUmSQEEsagXaKa_ajtvA.png" width=500/>
</p>

Има два основни подхода за създаване на алгоритъм за този проблем: **итеративен и рекурсивен**. При *итеративния* подреждаме кутиите в редица и започваме да ги отваряме една по една докато не намерим ключа или докато не свършат кутиите. Ако в някоя кутия намерим друга кутия, добавяме новата в редицата от кутии. При *рекурсивния* подход взимаме една кутия и преглеждаме всичко в нея. Ако има ключ сме готови. Ако има друга кутия правим същото нещо и преглеждаме какво има в нея.
<p align="center">
  <img src ="https://cdn-images-1.medium.com/max/2000/1*QrQ5uFKIhK3jQSFYeRBIRg.png" width=500 />
</p>
И двата подхода работят. Кой ви е по-интуитивен?  

Ако трябва да сравним пример с код нека погледнем и итеративната версия на задачата за пресмятане на факториел:
```c++
int factorial(int n){
    int fact = 1;
    for(int i = 1; i <= n; i++){
        fact *= i;
    }
    return fact;
}
```
На пръв поглед и двете функции работят еднакво. Итеративния подход обаче почи винаги е по-бърз и следователно се предпочита, но рекурсивния обикновено е по-чист и елегантен. Също така има много алгоритми, в чиято основа стои рекурсията.  

В [това](https://www.youtube.com/watch?v=k0bb7UYy0pY) видео подробно е обяснено и показано как се заделя памет, когато се използва рекурсия. Идеята е че при всяко извикване на функция се заделя специално парче памет за нейните локални променливи. Това парче се добавя към т.н. **call stack**, който запазва реда на извиканите функции. Когато използваме рекурсия, при всяко едно извикване на функцията ще се добавя ново попълнение към call stack-a, докато не се стигне до базовия случай и чак тогава паметта ще почне да се освобождава. Тоест ако имаме прекалено много извиквания можем да напълнм стака и да счупим програмата си. Докато при използването на итеративния подход функцията ще се извика само веднъж и ще бъде добавена към call stack-a веднъж. Затова изводът е:  

**Предпочитайте итеративен подход, освен ако алгоритъма не ви задължава да ползвате рекурсия.**

> “In order to understand recursion, one must first understand recursion.”