# Функции

## Защо са ни необходими функции?

Нека имаме следната задача: трябва да напишем програма, която проверява дали всяко число от матрица е просто, само ако размерът на матрицата е просто число. С познатите ни знания до момента кодът ни би изглеждал горе-долу така: 

```c++
int numbers[50][50];
int size;
cin >> size;

for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) {
        cin >> numbers[i][j];
    }
}

bool isSizePrime = true;
for (int i = 2; i < size; i++) {
    if (size % i == 0) {
        isSizePrime = false;
        break;
    }
}

if (isSizePrime) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            bool isNumberPrime = true;
            for (int k = 2; k < numbers[i][j]; k++) {
                if (numbers[i][j] % k == 0) {
                    isNumberPrime = false;
                    break;
                }
            }
            cout << numbers[i][j] << " is : " << (isNumberPrime ? "prime" : "not prime") << endl;
        }
    }
}
```
Какви изводи можем да направим анализирайки горния код?
* Имаме *5 нива на вложеност*, което само по себе си е знак за **нечист код и лоша четимост**.  
* На 2 различни места трябва да направим проверка за просто число и следователно имаме **повтарящ се код** (*copy-paste driven development*). Защо това е лошо? Ами ако в последствие например решим да оптимизираме начина, по който проверяваме дали едно число е просто, ще трябва да го променим и на двете места, тоест - двойно повече работа. Освен това когато друг програмист чете кода ни, ще му отнеме двойно повече време да проследи цялата ни логика.
* Програмата ни за момента **прави 2 неща** - грижи се за въвеждане/обхождане на матрицата и проверява на различни места дали едно число е просто.  

Функциите осигуряват решение именно на такива проблеми. Използват се когато **логиката на кода ни може може да бъде разделена на няколко основни части**, които могат да се наричат модули. Също така ни **позволяват преизползването на код**.

## Какво е функция?
Функция е просто парче код, което можем да извикваме многократно и да се изпълнява еднакво за различни стойности. Променливите, които функцията ползва се наричат **параметри**. Една функция се състои от тип на връщане, сигнатура и тяло, като в тялото трябва да има return statement.
```
returnType name([parameter 1, parameter 2, ..., parameter n])  // return type and signature
{                           
    statements;               
    return typeValue; 	  // return statement
}                             
```
*Сигнатурата* влючва **името на функцията, броят, подредбата и типа на параметрите, които тя приема.** *Return statement-a* сигнализира края на една функция. За нашия пример функция, която проверява дали едно число е просто би изглеждала така:

```c++
bool isPrime(int number){
   for (int i = 2; i < number; i++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
```
Името на тази функция е isPrime. Тя връща променлива от тип bool. Приема 1 параметър от тип int. 

## Извикване на функция

До сега сме писали целия си код в main функцията. Тя е специална ф-я, защото както знаете от нея започва изпълнението на всяка програма. Но вече можем да разделяме смислените части от кода си в други функции. Тях обаче викаме в main-а, като в скоби подадем аргументи, отговарящи на типа на параметрите на ф-ята. Например бихме извикали isPrime с различни числа ето така:
```c++
int main() {

   cout<< isPrime(7)<<endl; // true
   cout<< isPrime(9)<<endl; // false

   return 0;
}
```
Обърнете внимание на терминологията: когато говорим за променливите *в дефинирането и тялото* на функцията, ги наричаме **параметри**, а когато подаваме променливи, които имат различни стойности *при извикването* на функцията, ги наричаме **аргументи**.

Редът на изпълнение отново е последователен. Тоест ред след ред от main функцията се изпълнява, докато не се срещне извикване на някоя функция. Тогава се изпълнява ред по ред тялото на функцията докато не се срещне return statement (или докато не се изпълни цялото тяло). След това продължава изпълнението на кода от main функцията от реда след този, извикващ другата функция.

<p align="center">
  <img src ="https://qph.fs.quoracdn.net/main-qimg-2afbb55b51062bd13ffa47db87359450-c"/>
</p>

## Функции, които не връщат нищо

Има специален тип функции, които не връщат нищо, тоест **нямат return statement**. Те са от тип **void**.
```c++
void print(int number) {
   for (int i = 0; i < number; i++) {
         cout<< "Hello" << endl;
    }
}
```

## Функциите работят с копия

Когато подавате аргументи на една функция, тя реално прави копие на променливата и работи с него. Тоест чрез функции **не можете да променяте променливи**.

```c++
void increment(int parameter){
	parameter += 10;
	cout << parameter << endl;
}

int main() {
	int argument = 5;
	increment(argument);      // 15
	cout << argument << endl; // 5

	return 0;
}
```

## Function overloading
Понякога искате да осигурите еднакво поведение за различни типове. Например искате да напишете функция събираща цели числа, но и такава събираща дробни. Или пък искате да събирате 3 числа. Няколко функции **могат да имат еднакво име, но задължително трябва да имат различен брой или тип на аргументите**. Това се нарича function overloading.

```c++
int sum(int a, int b) {
	return a + b;
}

int sum(int a, int b, int c) {
	return a + b + c;
}

double sum(double a, double b) {
	return a + b;
}

int main() {
	cout << sum(2, 50) << endl;    // 52
	cout << sum(4, 7, 5) << endl;  // 16
	cout << sum(2.3, 2.4) << endl; // 4.7

	return 0;
}
```
*Не е възможно* две функции да се различават **само по return type** обаче, защото забележете, че когато викаме функциите ние не определяме какъв тип очакваме да ни бъде върнат. Тоест компилаторът няма как да знае коя от двете функции да извика.
```c++
int sum(int a, int b) {
	return a + b;
}

double sum(int a, int b) {  // compile-time error - "cannot overload functions distinguished by return type alone"
	return a + b;
}

int main() {
	cout << sum(2, 50) << endl;    // ?? which function to execute
	return 0;
}
```

## Място на функциите

Функциите, както променливите могат първо да се декларират. Разликата е че те нямат инициализация, а **имплементация**(*кода в тялото им*). **Декларацията** включва типа на връщане и сигнатурата на функцията и задължително трябва да бъде над main функцията. Имплементацията може да бъде както над така и под 
main-а. Например:

```c++
#include<iostream>
using namespace std;

bool isPrime(int number) {       //declaration and implementation at the same time
   for (int i = 2; i < number; i++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    ...
    return 0;
}

```

```c++
#include<iostream>
using namespace std;

bool isPrime(int number);  // declaration only

int main() {
    ...
    return 0;
}

bool isPrime(int number) {  //implementation
   for (int i = 2; i < number; i++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}

```

## Пример

Нашата задача от началото, написана с помощта на функции, вече в main-a само се грижи за създаването и обхождането на матрицата. Проверката за просто число е изнесена в отделна функция, като по този начин можем да я използваме многократно без да трябва да копираме кода.

```c++
#include<iostream>
using namespace std;

bool isPrime(int number);

int main() {
    int numbers[50][50];
    int size;
    cin >> size;

    for (int i = 0; i < size; i++) {
    	for (int j = 0; j < size; j++) {
		    cin >> numbers[i][j];
	    }
    }

    if (isPrime(size)){
	    for (int i = 0; i < 3; i++) {
		    for (int j = 0; j < 3; j++) {
		    	cout << numbers[i][j] << " is : " << (isPrime(numbers[i][j]) ? "prime" : "not prime") << endl;
	    	}
    	}
    }

    system("pause");
    return 0;
}

bool isPrime(int number) {
	for (int i = 2; i < number; i++) {
		if (number % i == 0) {
			return false;
		}
	}
	return true;
}
```