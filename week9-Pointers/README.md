# Указатели

Представете си паметта, в която се записват вашите променливи, като *линейна последователност от байтове*. Може да си го визуализирате като масив. И както при масивите всеки елемент си има индекс, *оказващ мястото му*, всеки байт от паметта си има пореден номер - *адрес*.  

Един от факторите с++ да се счита за толкова мощен (и труден) език е възможностите, които той предоставя относно управляването и контрола над паметта. Например с оператора **&(амперсанд)** можете да достъпите **адреса** на някоя променлива или константа.

<p align="center">
  <img src ="https://i.ibb.co/WxTRLjX/image.jpg"/>
</p>

```c++
int x = 16;
cout << &x <<endl; // 1000
```
*Забележка: с & достъпваме **адреса на първия байт на променливата**. Не можем да достъпим адреса на литерал. Тоест изрази от типа на &7, &(a + 1) са невалидни!*

## Тип указател

Типът на резултата, получен с оператора &, е **указател**. Тоест променлива от тип указател може да има стойност адреса на друга променлива. Декларирането на указател става като посочите типа на променливата, към която указателя ще сочи и символа *. Пример:  
```c++
int a = 9;   // normal variable of type int
int* p = &a; // pointer that points to the address of the variable a
```
Може да смените стойността на указателя. Например:  
```c++
int c = 12;  
p = &c; // the pointer now holds the address of the variable c
```
Може да създадете указател, който не сочи към нищо, приравнявайки го на **NULL/nullptr**.  
```c++
int* q = NULL;     // older, can be used as 0 and is interpreted as integer
int* d = nullptr;  // should be preferred, can only be used as a pointer type
```

## Оператора *
С този оператор можем да достъпим стойността, към която сочи указателя. Тоест това, което реално стои на дадения адрес. 
```c++
p = &a;     // pointer to the address of the variable a
a = 7; 
cout << *p; // the value that is on the address that p points to, the output will be 7
*p = 8;     // changing the value on that address
cout << a;  // 8
```

## Константи

Указателите също могат да бъдат константни. Константен указател към тип T, означава че той **не може да се пренасочи** към друг адрес. Което често се бърка с указател към константа от тип Т, което означава че съдържанието му не може да бъде променяно. Ето [тук](https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const) можете да почетете по-подробно.

```c++
int b = 5;
const int d = 2;

int* const p = &b; // p will always point to that address

const int* q = &d; // c points to the address of d which holds constant value of 2
int const* c = &d; // same as above
```

## Връзка между указатели и масиви
Нека имаме нормален масив: 
```c++
int array[] = { 1, 2, 3, 4};
``` 
Както споменахме когато учихме масиви, масивът съдържа елементи, които са наредени един до друг в паметта. Нещо, което не сме споменавали до сега, е че array всъщност е **константен указател към първия елемент на масива**. Тоест, ако използваме оператора *, можем да достъпим елементите, към които сочи този указател. А array + i е адресът на i-тия елемент. Например:
```c++
cout << *array; // 1
cout << *(array + 1); // 2  it is equivalent to array[1]
```

## Ползи
Както вече знаем, подавайки аргументи на функция по познатия ни начин, реално работи с копия на променливите и не променя стойността на подадените променливи. Ако подаваме указатели към променливите, вече чрез оператора * имаме право да променяме стойностите в адресите, които подаваме.
```c++
void passByValue(int a) {a = 10;}
void passByAddress(int *a) {*a = 10;}

int main(){
    int b = 5;
    passByValue(b); 
    cout << b;         // 5
    passByAddress(&b);
    cout << b;         // 10
}
```
## Масиви и функции
Можем да **подаваме масиви на функциите** по два начина:
```c++
void printArray(double array[], int length);
void printArray(double* array, int length)
```
И в двата случая се подава *адресът* на масива. Няма как да разберем колко елементи има, за това трябва да се подава и неговата *дължина*.  

Когато **от функция връщаме масив** трябва да сме сигурни, че той не е локална променлива, съществуваща само в тялото на функцията. След излизане от функцията паметта се маркира за свободна и програмата няма да се държи коректно. Това, което може да се направи е да подадем масив, в който ще запишем резултата и да върнем него.

## Псевдоними/ Референции

Те представляват **друго име** на вече съществуваща променлива. Псевдонимите или т.н. референции имат следния синтаксис:
```c++
int var = 5;
int &ref = var;
cout<< ref; // 5;
```
Псевдонимите имат следните разлики с указателите:
* Указател може да се пренасочи колкото пъти е необходимо, докато псевдонимите не могат да се пренасочат.
* Указателите могат да сочат към нищо (NULL), докато псевдонимите винаги сочат към обект.
* Не може да се вземе адреса на псевдоним както на указател.
* Няма "псевдонимна аритметика", докато указателите могат да се сравняват, изваждат и т.н.

Изказване от с++ форум:
> Even though a reference is often implemented using an address in the underlying assembly language, please do not think of a reference as a funny looking pointer to an object. A reference is the object. It is not a pointer to the object, nor a copy of the object. It is the object.

За още информация прочетете [тук](https://i.ibb.co/WxTRLjX/image.jpg)

